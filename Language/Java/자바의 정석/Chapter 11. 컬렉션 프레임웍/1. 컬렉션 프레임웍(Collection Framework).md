# 1.1. 컬렉션 프레임웍의 핵심 인터페이스

-   켤렉션을 크게 3가지 타입이 존재한다고 인식하고 3개의 인터페이스를 정의 : List, Set, Map
    -   컬렉션(Collection) : 다수의 데이터
-   List, Set을 구현한 컬렉션 클래스의 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의

<br>

> **Map.Entry**
>
> -   Map 인터페이스의 내부 인터페이스
> -   Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 정의해 놓음

<br>

# 1.2. ArrayList

-   List 인터페이스를 구현
    -   저장 순서 유지
    -   중복 허용
-   Obejct 배열을 이용해서 데이터를 순차적으로 저장
    -   저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존 배열에 저장된 내용을 새로운 배열로 복사한 다음 저장
-   생성할 때, 저장할 요소의 개수보다 약간 여유로운 크기로 생성하는 것이 좋음
    -   생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만, 이 과정에서 처리시간이 많이 소요됨
 
<br>

# 1.3. LinkedList

## Array vs. LinkedList

-   Array : 모든 데이터가 연속적으로 존재
-   LinkedList : 불연속적으로 존재하는 데이터를 서로 연결(link)
    -   각 요소(node)는 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성됨

    ```
    class Node {
      Node next; // 다음 요소의 주소
      Object obj; // 데이터
    }
    ```
<br>

## 데이터 조작

-   삭제 : 삭제하고자 하는 요소의 이전 요소가 이후 요소를 참조하도록 변경
-   추가 : 새로운 요소를 생성한 뒤, 추가하고자 하는 위치의 이전 요소가 새로운 요소를 참조하고 새로운 요소가 그 다음 요소를 참조하도록 변경

<br>

## **이중 연결 리스트 (Doubly LinkedList)**

-   단방향이기 때문에 이전 요소에 대한 접근이 어려운 단방향 연결 리스트의 단점을 보완
-   각 요소는 이전 요소에 대한 참조를 포함

```
class Node {
  Node next; // 다음 요소의 주소
  Node previous; // 이전 요소의 주소
  Obejct obj; // 데이터
}
```

<br>

## **이중 원형 연결리스트 (Doubly Circular LinkedList)**

-   양방향 연결리스트의 첫번째 요소와 마지막 요소를 서로 연결시켜 양방향 연결리스트의 접근성을 보다 향상

<br>

# Stack과 Queue

## **Priority Queue**

-   Queue 인터페이스의 구현체 중 하나
-   저장 순서에 관계 없이 우선순위(priority)가 높은 것부터 꺼냄
    -   숫자가 작을수록 높은 우선순위
-   null 저장 불가 (`NullPointerException`)
-   객체를 저장할 때는 객체를 비교하기 위한 방법을 제공해야 함

<br>

### **Priority Queue의 구현**

-   저장공간으로 배열을 사용
-   '힙(heap)'의 형태로 저장

> **힙(heap)**
>
> -   이진 트리의 한 종류
> -   가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있음
> -   JVM 힙(heap)과는 이름만 같고 다름

<br>
