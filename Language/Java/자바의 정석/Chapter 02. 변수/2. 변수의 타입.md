
<br>

| **분류** | **내용** |
| --- | --- |
| **기본형 변수** | \- 실제 값(data)을 저장 <br>  \- 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double) |
| **참조형 변수** | \- 어떤 값이 저장되어 있는 객체의 주소(memory address)를 값으로 가짐  <br> \- 변수의 타입으로 클래스의 이름을 사용. 즉, 클래스의 이름이 참조 변수의 타입  <br> \- null 또는 객체의 주소(4byte, 0x0~0xffffffff)를 값으로 가짐 <br>  \- 8개 기본형을 제외한 나머지 타입 |


- 자료형(data type) vs. 타입(type)
  - 타입(type) > 자료형(data type)
  - 자료형(data type) : 저장할 값(data)에 따라 구분되는 기본형의 종류를 얘기할 때 사용
  - 타입(type) : 항상 객체의 주소를 저장하여 객체의 종류에 의해 구분되는 참조형 변수릐 종류를 구분할 때 사용

<br>


# **기본형 Primitive Type**

-   8개 타입

|   | **1 byte** | **2 byte**  | **4 byte** | **8 byte** |
| --- | --- | --- | --- | --- |
| **논리형** | boolean |   |   |   |
| **문자형** |   | char |   |   |
| **정수형** | byte (-2^7 ~ 2^7-1) | short (-2^15 ~ 2^15-1) | **int (기본형) (-2^31 ~ 2^31-1, 약 20억)** | long (-2^63 ~ 2^63-1) |
| **실수형** |   |   | float | **double (기본형)** |

-   특징
    -   boolean 외의 7개 기본형은 서로 연산과 변환 가능
        -   char : 문자를 내부적으로 정수(유니코드)로 저장하여 정수형 또는 실수형과 연산 가능
    -   정수형 중 int가 CPU가 가장 효율적으로 처리할 수 있는 타입
    -   float이 더 큰 값까지 저장할 수 있지만, 정밀도는 double이 좋음

        | 타입 | 저장 가능 범위 | 정밀도 |
        | --- | --- | --- |
        | float | 1.4 \* 10^(-45) ~ 3.4 \* 10^38 | 7자리 |
        | double | 4.9 \* 10^(-324) ~ 1.8 \* 10^308 | 15자리 |



<br>

# **상수와 리터럴 Constant & Literal**

## **상수 Constant**

-   반드시 선언과 동시에 초기화

```
final int MAX_SPEED;
MAX_SPEED = 10; // 에러. 상수의 값은 변경될 수 없음
```

-   모두 대문자로, 여러 단어로 이루어진 경우 `_`로 구분
-   리터럴에 '의미 있는 이름'을 붙여서 코드의 이해와 수정을 용이하게 함

<br>

## **리터럴 Literal**

-   기존의 상수. 그 자체로 값을 의미
    -   리터럴에 접미사를 붙여서 타입을 구분
        -   long : `l` 또는 `L`
            -   없으면 int
            -   byte, short의 리터럴은 별도로 존재하지 않으며 int 타입의 리터럴을 사용
        -   16진수 : `0x` 또는 `0X`
        -   8진수 : `0`
        -   2진수 : `0b` 또는 `0B`
    -   (JDK 1.7~) 정수형 리터럴 중간에 구분자 `_` 넣을 수 있음
    -   float : `f` 또는 `F`
    -   double : `d` 또는 `D` (기본형이므로 생략 가능)
 
-   리터럴 타입과 변수의 타입이 일치하지 않아도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용
    -   byte, short : int 타입의 리터럴를 사용하되, 해당 변수가 저장할 수 있는 범위에 속해야 함

<br>

### **문자 리터럴과 문자열 리터럴**

-   문자 리터럴 : 작은 따옴표로 문자 하나를 감쌈. 빈 문자 허용 X
-   문자열 리터럴 : 큰 따옴표로 문자를 감쌈. 빈 문자열을 허용 O
    -   String은 클래스이므로 객체 생성 연산자 `new` 사용
    -   덧셈 연산자로 문자열 결합 가능
        -   피연산자 중 하나라도 문자열이면 다른 피연산자도 문자열로 변환하여 결합

<br>

## **형식화된 출력 - printf()**

-   지시자(Specifier)를 이용해 변수의 값을 여러 형식으로 변환하여 출력할 수 있음
    -   자주 사용되는 지시자 ([Java API Formatter 클래스](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html) 참고)

        | 지시자 | 설명 |
        | --- | --- |
        | `%b` | boolean |
        | `%d`, `%f` | 10진수 int, float(소수점 이하 7자리에서 반올림) |
        | `%o` | 8진수 |
        | `%x`, `%X` | 16진수 |
        | `%e`, `%E` | 지수 형태 표현 |
        | `%c` | 문자 |
        | `%s` | 문자열 |

-   지시자 사이에 숫자를 입력하여 출력될 값이 차지할 공간의 크기를 지정할 수 있음

```
// 기본 : 오른쪽 정렬
System.out.printf("[%5d]%n", 10); // [   10]
// - : 왼쪽 정렬
System.out.printf("[%-5d]%n", 10); // [10   ]
// 오른쪽 정렬 + 빈 공간 채울 문자 지정
System.out.printf("[%05d]%n", 10); // [00010]
// 소수점 자리 지정
System.out.printf("[%.3f]%n", 0.1234); // [0.123]
```

-  `%#x`, `%#X`, `%#o` : 접두사 `0x`, `0X`, `0` 붙음

<br>

# 화면에서 입력받기 - Scanner

-   `Scanner` 클래스 이용
    -   JDK 1.6 부터는 `Console` 클래스를 이용할 수 있으나, 이클립스와 같은 IDE에서 잘 작동하지 않음

```
import java.util.*;

Scanner scanner = new Scanner(System.in);

String input = scanner.nextLine();
// 숫자로 바로 입력 받기
int num = scanner.nextInt(); // nextFloat() 도 가능
```
<br>
