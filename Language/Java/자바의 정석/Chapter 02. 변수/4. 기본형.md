# 논리형 - boolean

-   true, false(기본값)

<br>

# 문자형 - char

-   문자의 유니코드(정수)를 저장
    -   문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있음
    -   int로 형변환하면 유니코드를 알 수 있음
-   특수문자를 저장할 수 있음

    | 특수 문자 | 문자 리터럴 |
    | --- | --- |
    | tab | `\t` |
    | backspace | `\b` |
    | form feed | `\f` |
    | new line | `\n` |
    | carriage return | `\r` |
    | 역슬래쉬 | `\\` |
    | 작은따옴표 | `\'` |
    | 큰따옴표 | `\"` |
    | 유니코드(16진수) 문자 | `\u유니코드` |

<br>

# 정수형 - byte, short, int, long

-   기본형 : int
-   실제로는 2진수로 바뀌어 저장됨 : S (부호비트) + n (타입의 크기(bit))  
    -   부호비트 : 양수는 0, 음수는 1
    -   타입의 크기를 알면 정수형의 표현범위를 계산할 수 있음

        | 자료형 | 저장 가능한 값의 범위 | bit | byte |
        | --- | --- | --- | --- |
        | byte | \-2^7 ~ 2^7-1 | 8 | 1 |
        | short | \-2^15 ~ 2^15-1 | 16 | 2 |
        | int | \-2^31 ~ 2^31-1, 약 20억 | 32 | 4 |
        | long | \-2^63 ~ 2^63-1 | 64 | 8 |

-   대체로 int를 사용하는 것이 효율적
    -   JVM 피연산자 스택이 피 연산자를 4 byte 단위로 저장하기 떄문에 byte, short를 계산할 때는 4 byte로 변환하여 연산을 수행
-   오버플로우(overflow)가 발생하면 에러가 발생하지는 않지만 예상했던 결과를 얻을 수 없음
    -   최대값 + 1 → 최소값, 최소값 - 1 → 최대값
    -   부호가 없는 경우 : 2진수로 `0000`이 될 떄 발생
    -   부호가 있는 경우 : 부호지트가 0(양수)에서 1(음수)가 될 때 발생

<br>

# 실수형 - float, double

## 실수형의 범위와 정밀도

| 타입 | 저장 가능한 값의 범위 (양수) | 정밀도 | bit | byte |
| --- | --- | --- | --- | --- |
| float | 1.4 \* 10^(-45) ~ 3.4 \* 10^38 | 7자리 | 32 | 4 |
| double | 4.9 \* 10^(-324) ~ 1.8 \* 10^308 | 15자리 | 64 | 8 |

-   정밀도 : 몇 자리의 10진수를 오차없이 저장할 수 있는가
-   `-` 부호 붙이면 음의 범위
-   0은 포함되지 않음
-   얼마나 0에 가깝게 표현할 수 있는가

<br>

## 값 저장 형식

-   부호(S) + 지수(E) + 가수(M)
    -   float : S(1) + E(8) + M(23)
    -   double : S(1) + E(11) + M(52)
-   10의 제곱을 곱한 형태 (±M \* 10^E)

<br>

## 오버플로우와 언더플로우

-   오버플로우 발생시 무한대(infinity)
-   언더플로우(underflow)
    -   실수형의 최소값보다 작은 값인 경우
    -   0이 됨
 
<br>
